/***************************************************************************
 *                                                                         *
 *   Copyright (C) 2006 by Kanardia d.o.o.                                 *
 *   Writen by:                                                            *
 *      Ales Krajnc [ales.krajnc@kanardia.eu]                              *
 *      May - July 2006                                                    *
 *                                                                         *
 *   Licence:                                                              *
 *      GNU - General Public License as published by the                   *
 *            Free Software Foundation                                     *
 *                                                                         *
 ***************************************************************************/

// The original model file for 2005-2010 (WMM2005.cof)
/* -----------------------------------------------------------------------------
   WMM-2005  2005.00 12  8  0 2005.00 2010.00   -1.0  600.0          WMM-2005  0
 0 1-29556.8     0.0    8.0     0.0                                  WMM-2005  1
 1 1 -1671.7  5079.8   10.6   -20.9                                  WMM-2005  2
 0 2 -2340.6     0.0  -15.1     0.0                                  WMM-2005  3
 1 2  3046.9 -2594.7   -7.8   -23.2                                  WMM-2005  4
 2 2  1657.0  -516.7   -0.8   -14.6                                  WMM-2005  5
 0 3  1335.4     0.0    0.4     0.0                                  WMM-2005  6
 1 3 -2305.1  -199.9   -2.6     5.0                                  WMM-2005  7
 2 3  1246.7   269.3   -1.2    -7.0                                  WMM-2005  8
 3 3   674.0  -524.2   -6.5    -0.6                                  WMM-2005  9
 0 4   919.8     0.0   -2.5     0.0                                  WMM-2005 10
 1 4   798.1   281.5    2.8     2.2                                  WMM-2005 11
 2 4   211.3  -226.0   -7.0     1.6                                  WMM-2005 12
 3 4  -379.4   145.8    6.2     5.8                                  WMM-2005 13
 4 4   100.0  -304.7   -3.8     0.1                                  WMM-2005 14
 0 5  -227.4     0.0   -2.8     0.0                                  WMM-2005 15
 1 5   354.6    42.4    0.7     0.0                                  WMM-2005 16
 2 5   208.7   179.8   -3.2     1.7                                  WMM-2005 17
 3 5  -136.5  -123.0   -1.1     2.1                                  WMM-2005 18
 4 5  -168.3   -19.5    0.1     4.8                                  WMM-2005 19
 5 5   -14.1   103.6   -0.8    -1.1                                  WMM-2005 20
 0 6    73.2     0.0   -0.7     0.0                                  WMM-2005 21
 1 6    69.7   -20.3    0.4    -0.6                                  WMM-2005 22
 2 6    76.7    54.7   -0.3    -1.9                                  WMM-2005 23
 3 6  -151.2    63.6    2.3    -0.4                                  WMM-2005 24
 4 6   -14.9   -63.4   -2.1    -0.5                                  WMM-2005 25
 5 6    14.6    -0.1   -0.6    -0.3                                  WMM-2005 26
 6 6   -86.3    50.4    1.4     0.7                                  WMM-2005 27
 0 7    80.1     0.0    0.2     0.0                                  WMM-2005 28
 1 7   -74.5   -61.5   -0.1     0.6                                  WMM-2005 29
 2 7    -1.4   -22.4   -0.3     0.4                                  WMM-2005 30
 3 7    38.5     7.2    1.1     0.2                                  WMM-2005 31
 4 7    12.4    25.4    0.6     0.3                                  WMM-2005 32
 5 7     9.5    11.0    0.5    -0.8                                  WMM-2005 33
 6 7     5.7   -26.4   -0.4    -0.2                                  WMM-2005 34
 7 7     1.8    -5.1    0.6     0.1                                  WMM-2005 35
 0 8    24.9     0.0    0.1     0.0                                  WMM-2005 36
 1 8     7.7    11.2    0.3    -0.2                                  WMM-2005 37
 2 8   -11.6   -21.0   -0.4     0.1                                  WMM-2005 38
 3 8    -6.9     9.6    0.3     0.3                                  WMM-2005 39
 4 8   -18.2   -19.8   -0.3     0.4                                  WMM-2005 40
 5 8    10.0    16.1    0.2     0.1                                  WMM-2005 41
 6 8     9.2     7.7    0.4    -0.2                                  WMM-2005 42
 7 8   -11.6   -12.9   -0.7     0.4                                  WMM-2005 43
 8 8    -5.2    -0.2    0.4     0.4                                  WMM-2005 44
 0 9     5.6     0.0    0.0     0.0                                  WMM-2005 45
 1 9     9.9   -20.1    0.0     0.0                                  WMM-2005 46
 2 9     3.5    12.9    0.0     0.0                                  WMM-2005 47
 3 9    -7.0    12.6    0.0     0.0                                  WMM-2005 48
 4 9     5.1    -6.7    0.0     0.0                                  WMM-2005 49
 5 9   -10.8    -8.1    0.0     0.0                                  WMM-2005 50
 6 9    -1.3     8.0    0.0     0.0                                  WMM-2005 51
 7 9     8.8     2.9    0.0     0.0                                  WMM-2005 52
 8 9    -6.7    -7.9    0.0     0.0                                  WMM-2005 53
 9 9    -9.1     6.0    0.0     0.0                                  WMM-2005 54
 010    -2.3     0.0    0.0     0.0                                  WMM-2005 55
 110    -6.3     2.4    0.0     0.0                                  WMM-2005 56
 210     1.6     0.2    0.0     0.0                                  WMM-2005 57
 310    -2.6     4.4    0.0     0.0                                  WMM-2005 58
 410     0.0     4.8    0.0     0.0                                  WMM-2005 59
 510     3.1    -6.5    0.0     0.0                                  WMM-2005 60
 610     0.4    -1.1    0.0     0.0                                  WMM-2005 61
 710     2.1    -3.4    0.0     0.0                                  WMM-2005 62
 810     3.9    -0.8    0.0     0.0                                  WMM-2005 63
 910    -0.1    -2.3    0.0     0.0                                  WMM-2005 64
1010    -2.3    -7.9    0.0     0.0                                  WMM-2005 65
 011     2.8     0.0    0.0     0.0                                  WMM-2005 66
 111    -1.6     0.3    0.0     0.0                                  WMM-2005 67
 211    -1.7     1.2    0.0     0.0                                  WMM-2005 68
 311     1.7    -0.8    0.0     0.0                                  WMM-2005 69
 411    -0.1    -2.5    0.0     0.0                                  WMM-2005 70
 511     0.1     0.9    0.0     0.0                                  WMM-2005 71
 611    -0.7    -0.6    0.0     0.0                                  WMM-2005 72
 711     0.7    -2.7    0.0     0.0                                  WMM-2005 73
 811     1.8    -0.9    0.0     0.0                                  WMM-2005 74
 911     0.0    -1.3    0.0     0.0                                  WMM-2005 75
1011     1.1    -2.0    0.0     0.0                                  WMM-2005 76
1111     4.1    -1.2    0.0     0.0                                  WMM-2005 77
 012    -2.4     0.0    0.0     0.0                                  WMM-2005 78
 112    -0.4    -0.4    0.0     0.0                                  WMM-2005 79
 212     0.2     0.3    0.0     0.0                                  WMM-2005 80
 312     0.8     2.4    0.0     0.0                                  WMM-2005 81
 412    -0.3    -2.6    0.0     0.0                                  WMM-2005 82
 512     1.1     0.6    0.0     0.0                                  WMM-2005 83
 612    -0.5     0.3    0.0     0.0                                  WMM-2005 84
 712     0.4     0.0    0.0     0.0                                  WMM-2005 85
 812    -0.3     0.0    0.0     0.0                                  WMM-2005 86
 912    -0.3     0.3    0.0     0.0                                  WMM-2005 87
1012    -0.1    -0.9    0.0     0.0                                  WMM-2005 88
1112    -0.3    -0.4    0.0     0.0                                  WMM-2005 89
1212    -0.1     0.8    0.0     0.0                                  WMM-2005 90
----------------------------------------------------------------------------- */

#include <cassert>
#include <cmath>
#include "GeoMagModel.h"
#include "MathEx.h"

#define RECL     81
#define MAXREAD  RECL+4
#define MAXCOEFF_2 (MAXDEG*(MAXDEG+3)/2+1)
#define MAXDEG_2   (MAXDEG+1)
#define NaN log(-1.0)

// ---------------------------------------------------------------------------
// This method is called only when the new model is ready (in year 2010).
// The method constructs (reads) model coefficients from the given file and
// arrange them in a more compact form.
// ---------------------------------------------------------------------------
/*#include <stdio.h>
void GeoMagModel::ReadAndPrintCoefficients()
{
	float afghM[MAXCOEFF];
	float afghC[MAXCOEFF];

	// Modify this line
	FILE *fIn = fopen("WMM2005.cof", "rt");
	assert(fIn);

	char acLine[85];

	// Get the first (description line);
	fgets(acLine,MAXREAD,fIn);
	char  acModelName[9];
	float fEpoch;
   int iNMain;
	int iNChange;
   int iMax3;
	float fYearMin;
	float fYearMax;
	float fAltMin;
	float fAltMax;

	sscanf(acLine, "%s%f%d%d%d%f%f%f%f",
		acModelName, // name of the model
		&fEpoch,     // epoch year ...
      &iNMain,     // degree of the main model
		&iNChange,   // degree of the estimation of change during the period
		&iMax3,      // don't know
		&fYearMin,   // valid from
		&fYearMax,   // valid to
		&fAltMin,    // minimal altitude (km)
		&fAltMax     // maximal altitude (km)
	);

	int iNMax = iNMain > iNChange ? iNMain : iNChange;

   int ii = 0;
   int ios = 0;
   for (int nn = 1; nn <= iNMax; ++nn) {
	 	for (int mm = 0; mm <= nn; ++mm) {
			// read m
			int m;
	      fgets(acLine, 3, fIn);
         acLine[3]='\0';
         sscanf(acLine, "%d", &m);
			// read n
			int n;
         fgets(acLine, 3, fIn);
         acLine[3]='\0';
         sscanf(acLine, "%d", &n);
	      assert((nn == n) && (mm == m));

			// read gMain, hMain, gChange, hChange, (model name, line)
			float fgMain, fhMain, fgChange, fhChange;
         fgets(acLine, MAXREAD-4, fIn);
         sscanf(acLine, "%f%f%f%f", &fgMain, &fhMain, &fgChange, &fhChange);

    		ii++;
			if(nn <= iNMain)
				afghM[ii] = fgMain;
			if(nn <= iNChange)
				afghC[ii] = fgChange;

    		if (m != 0) {
	       	ii++;
				if(nn <= iNMain)
					afghM[ii] = fhMain;
				if(nn <= iNChange)
					afghC[ii] = fhChange;
	    	}
	 	} // for mm
   } // for nn
	fclose(fIn);

	// print the afghM, afghC
	printf("\nafghM = {\n");
	for(int i=0; i<MAXCOEFF; i++) {
		printf(" %7.1f,", afghM[i]);
	}
	printf("\n};\n");

	printf("\nafghC = {\n");
	for(int i=0; i<MAXCOEFF; i++) {
		printf(" %7.1f,", afghC[i]);
	}
	printf("\n};\n");
	// Get the output and copy it into the m_afGMH and m_afGMC fields below.
}
*/
// ---------------------------------------------------------------------------
// Basic model coefficients for the year 2005
const float GeoMagModel::s_afGHM[MAXCOEFF] = {
 0.0, // not used due to legacy fortran code
 -29556.8, -1671.7,  5079.8, -2340.6,  3046.9, -2594.7,  1657.0,  -516.7,
	1335.4, -2305.1,  -199.9,  1246.7,   269.3,   674.0,  -524.2,   919.8,
	 798.1,   281.5,   211.3,  -226.0,  -379.4,   145.8,   100.0,  -304.7,
   -227.4,   354.6,    42.4,   208.7,   179.8,  -136.5,  -123.0,  -168.3,
    -19.5,   -14.1,   103.6,    73.2,    69.7,   -20.3,    76.7,    54.7,
   -151.2,    63.6,   -14.9,   -63.4,    14.6,    -0.1,   -86.3,    50.4,
     80.1,   -74.5,   -61.5,    -1.4,   -22.4,    38.5,     7.2,    12.4,
     25.4,     9.5,    11.0,     5.7,   -26.4,     1.8,    -5.1,    24.9,
      7.7,    11.2,   -11.6,   -21.0,    -6.9,     9.6,   -18.2,   -19.8,
     10.0,    16.1,     9.2,     7.7,   -11.6,   -12.9,    -5.2,    -0.2,
      5.6,     9.9,   -20.1,     3.5,    12.9,    -7.0,    12.6,     5.1,
     -6.7,   -10.8,    -8.1,    -1.3,     8.0,     8.8,     2.9,    -6.7,
     -7.9,    -9.1,     6.0,    -2.3,    -6.3,     2.4,     1.6,     0.2,
     -2.6,     4.4,     0.0,     4.8,     3.1,    -6.5,     0.4,    -1.1,
      2.1,    -3.4,     3.9,    -0.8,    -0.1,    -2.3,    -2.3,    -7.9,
      2.8,    -1.6,     0.3,    -1.7,     1.2,     1.7,    -0.8,    -0.1,
     -2.5,     0.1,     0.9,    -0.7,    -0.6,     0.7,    -2.7,     1.8,
     -0.9,     0.0,    -1.3,     1.1,    -2.0,     4.1,    -1.2,    -2.4,
     -0.4,    -0.4,     0.2,     0.3,     0.8,     2.4,    -0.3,    -2.6,
      1.1,     0.6,    -0.5,     0.3,     0.4,     0.0,    -0.3,     0.0,
     -0.3,     0.3,    -0.1,    -0.9,    -0.3,    -0.4,    -0.1,     0.8
};

// Estimated change during 2005-2010 period.
// XXX:
//const float GeoMagModel::s_afGHC[MAXCOEFF]  __attribute__ ((section (".rodata"))) = {
const float GeoMagModel::s_afGHC[MAXCOEFF] = {
      0.0,	// not used due to legacy fortran code
      8.0,    10.6,   -20.9,   -15.1,    -7.8,   -23.2,    -0.8,   -14.6,
      0.4,    -2.6,     5.0,    -1.2,    -7.0,    -6.5,    -0.6,    -2.5,
      2.8,     2.2,    -7.0,     1.6,     6.2,     5.8,    -3.8,     0.1,
     -2.8,     0.7,     0.0,    -3.2,     1.7,    -1.1,     2.1,     0.1,
      4.8,    -0.8,    -1.1,    -0.7,     0.4,    -0.6,    -0.3,    -1.9,
      2.3,    -0.4,    -2.1,    -0.5,    -0.6,    -0.3,     1.4,     0.7,
      0.2,    -0.1,     0.6,    -0.3,     0.4,     1.1,     0.2,     0.6,
      0.3,     0.5,    -0.8,    -0.4,    -0.2,     0.6,     0.1,     0.1,
      0.3,    -0.2,    -0.4,     0.1,     0.3,     0.3,    -0.3,     0.4,
      0.2,     0.1,     0.4,    -0.2,    -0.7,     0.4,     0.4,     0.4,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,
      0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0,     0.0
};

// degree of the "main" model
const int GeoMagModel::s_iNM = 12;
// degree of the "change" model
const int GeoMagModel::s_iNC =  8;
// model year
const float GeoMagModel::s_fModelDate = 2005.0;

// Current model date
float GeoMagModel::s_fDate = s_fModelDate+2.5;

// --------------------------------------------------------------------------
/*! Constructor sets the date into the middle of epoch (assuming 5 year
    epoch). It is advisible that correct date is specified using SetDate
    member to get more precise coefficients.
 */
GeoMagModel::GeoMagModel()
{
	// reset the variables
	for(int i=0; i<MAXCOEFF; i++)
		m_afGH[i] = 0.0;
	m_fx = m_fy = m_fz = 0.0;

	// if for some reason someone forgets to set the correct date, use
   // the middle of the valid epoch.
	SetDate(s_fDate);
}

// --------------------------------------------------------------------------
/*! Extrapolates linearly a spherical harmonic model coefficients
	 out of known model (s_afGHM) and expected change model (s_afGHC).
	 The coefficients (Schmidt quasi-normal internal spherical harmonic
    coefficients) are stored in m_afGH array. Once this array is set,
    any number of Evaluate() member function calls can be made.

    This method is typically called before the Evaluate().
 */

void GeoMagModel::SetDate(
	float fDate //!< Date of resulting model (in decimal year).
)
{
	// make sure the date is valid
	assert(fDate >= s_fModelDate);

	if(fDate==s_fDate)
		return;
	s_fDate = fDate;

	// difference between given date and the base model date.
   const float fFactor = fDate - s_fModelDate;

 	const int nMax = GetMaxDegree();
	const int k = nMax*(nMax+2);
	for (int i = 1; i <= k; i++) {
		m_afGH[i] = s_afGHM[i] + fFactor * s_afGHC[i];
	}
}

// --------------------------------------------------------------------------
/*! Calculates field components from spherical harmonic coefficiets stored in
    m_afGH array. The array must be set for given model date. This is
    typically done before the call to Evaluate() using the SetDate() function
    member.

	 For the given input via function arguments, components (x,y,z) of
    magnetic field are calculated. NED coordinate system is assumed. The result
    is stored in the m_fx, m_fy and m_fz object variables. To get the x, y and z
    values, call GetX(), GetY() and GetZ() member functions, respectively.
	 To get the inclination, declination and field strengt, call the GetIDH().
 */
void GeoMagModel::Evaluate(
	float fLat, 	//!< geodetic nord latitude in radians
	float fLon, 	//!< geodetic east longitude in radians
	float fElev, 	//!< altitude above WGS84 elipsoid in kilometers
	int   iExt,    //!< External coefficients flag (=0 if none)
	float fExt1,   //!< Some external coefficients (don't know how to use)
	float fExt2,   //!< Some external coefficients (don't know how to use)
	float fExt3    //!< Some external coefficients (don't know how to use)
) const
{
	// check latitude range [-90,90]
	assert(fLat >= -M_PI_2 && fLat <= M_PI_2);
	// check longitude range [0,360]
	assert(fLon >= 0 && fLon <= 2*M_PI);

   const float fEarthsRadius = 6371.2;       // km
   //const float fd2r          = 0.01745329; // degree to radian
   const float a2 = 40680631.59;             // WGS84
   const float b2 = 40408299.98;             // WGS84

	int   nMax = GetMaxDegree();              // max degree (see the constants)

	// working variables
   float aa, bb, cc;
   float rr;
   float sl[MAXDEG_2];
   float cl[MAXDEG_2];
   float p [MAXCOEFF_2];
   float q [MAXCOEFF_2];
   int ii,j,k;

   float r = fElev;

   double dArg = fLat; 					// use double to enhance precision ??
   float  fSinLat = sin(dArg);

	aa = fLat;
	// To avoid singularity problems ...
	if ((M_PI_2 - fLat) < 0.0001)
      aa = M_PI_2-0.0001;           // 637 m from North pole
   if ((90.0 + fLat) < 0.001)
      	aa = -(M_PI_2-0.0001);     // 637 m from South pole
   dArg = aa; 								// use double to enhance precision ??
   float fCosLat = cos(dArg);
   dArg = fLon;
   sl[1] = sin(dArg);
   cl[1] = cos(dArg);

	// reset result
	m_fx = m_fy = m_fz = 0.0;


   float sd = 0.0;
   float cd = 1.0;
	// This section of code is needed if the coordinates are
   // given in geodetic system.
   // if (bGeodetic==true)
   {
      aa = a2 * fCosLat * fCosLat;
      bb = b2 * fSinLat * fSinLat;
      cc = aa + bb;
      dArg = cc;
      float dd = std::sqrt(dArg);
      dArg = fElev * (fElev + 2.0 * dd) + (a2 * aa + b2 * bb) / cc;
      r = std::sqrt(dArg);
      cd = (fElev + dd) / r;
      sd = (a2 - b2) / dd * fSinLat * fCosLat / r;
      aa = fSinLat;
      fSinLat = fSinLat * cd - fCosLat * sd;
      fCosLat = fCosLat * cd + aa * sd;
   }

	// Here we start with the calculation
	// I don't have a slight idea what is going on :)
   float fRatio = fEarthsRadius / r;
   dArg = 3.0;
   aa = std::sqrt( dArg );
   p[1] = 2.0 * fSinLat;
   p[2] = 2.0 * fCosLat;
   p[3] = 4.5 * fSinLat * fSinLat - 1.5;
   p[4] = 3.0 * aa * fCosLat * fSinLat;
   q[1] = -fCosLat;
   q[2] = fSinLat;
   q[3] = -3.0 * fCosLat * fSinLat;
   q[4] = aa * (fSinLat * fSinLat - fCosLat * fCosLat);

   int l = 1;
   int n = 0;
   int m = 1;
   int npq = (nMax * (nMax + 3)) / 2;
	// a loop over npq times - npq is 90 or more
	for (k = 1; k <= npq; ++k) {
		// TODO check warning
	   float fm,fn; // working variables
   	if (n < m) {
	 		m = 0;
	 		n = n + 1;
	 		dArg = fRatio;
			// in C++ it may be faster to use int iPower and then pow(dArg,iPower)
			// due to pow parameter specialization
/*	 		double dPower =  n + 2;
	 		rr = pow(dArg,dPower);*/
	 		int iPower =  n + 2;
	 		rr = std::pow(dArg,iPower);
	 		fn = n;
      }
      fm = m;
      if (k >= 5) {
	 		if (m == n) {
	    		dArg = (1.0 - 0.5/fm);
	    		aa = std::sqrt( dArg );
	    		j = k - n - 1;
	    		p[k] = (1.0 + 1.0/fm) * aa * fCosLat * p[j];
	    		q[k] = aa * (fCosLat * q[j] + fSinLat/fm * p[j]);
	    		sl[m] = sl[m-1] * cl[1] + cl[m-1] * sl[1];
	    		cl[m] = cl[m-1] * cl[1] - sl[m-1] * sl[1];
	 		}
	 		else	{
	    		dArg = fn*fn - fm*fm;
	    		aa = std::sqrt( dArg );
	    		dArg = ((fn - 1.0)*(fn-1.0)) - (fm * fm);
	    		bb = std::sqrt( dArg )/aa;
	    		cc = (2.0 * fn - 1.0)/aa;
	    		ii = k - n;
	    		j = k - 2 * n + 1;
	    		p[k] = (fn + 1.0) * (cc * fSinLat/fn * p[ii] - bb/(fn - 1.0) * p[j]);
	    		q[k] = cc * (fSinLat * q[ii] - fCosLat/fn * p[ii]) - bb * q[j];
	 		}
      }

	 	aa = rr * m_afGH[l];

      if (m == 0) {
	    	m_fx = m_fx + aa * q[k];
		   m_fz = m_fz - aa * p[k];
	 		l = l + 1;
      }
      else {
	    	bb = rr * m_afGH[l+1];
		   cc = aa * cl[m] + bb * sl[m];
		   m_fx = m_fx + cc * q[k];
		   m_fz = m_fz - cc * p[k];
		   if (fCosLat > 0) {
				m_fy = m_fy + (aa * sl[m] - bb * cl[m]) *
			   			fm * p[k]/((fn + 1.0) * fCosLat);
		   }
		   else {
				m_fy = m_fy + (aa * sl[m] - bb * cl[m]) * q[k] * fSinLat;
		   }
		   l = l + 2;
      }
      m = m + 1;
   }

   if (iExt != 0)  {
      aa = fExt2 * cl[1] + fExt3 * sl[1];
	 	m_fx = m_fx - fExt1 * fCosLat + aa * fSinLat;
		m_fy = m_fy + fExt2 * sl[1] - fExt3 * cl[1];
		m_fz = m_fz + fExt1 * fSinLat + aa * fCosLat;
   }

	// it seems like rotation of vector in 2D
	aa = m_fx;
	m_fx = m_fx * cd + m_fz * sd;
	m_fz = m_fz * cd - aa * sd;
}

// --------------------------------------------------------------------------
/*! The CalcIDH takes m_fx, m_fy and m_fz values and converts them
    into inclination fInc, declination fDec and field strenght fStrength.
    A consideration for very small field strength or very large inclination
	 angles is given. fInc or/and fDec may hold a NaN value, which indicates
	 an invalid condition.
 */
void GeoMagModel::CalcIDH(
	float& fInc, 		//!< [out] inclination in radians
	float& fDec, 		//!< [out] declination in radians
	float& fStrength  //!< [out] field strength
) const
{
	// A small number to check against.
   const float fSmallNumber = 0.0001;

	// Strength in x-y plane (used to get the declination)
	double dh2 = m_fx*m_fx + m_fy*m_fy;
	// Total strenght (square)
	double dh3 = dh2 + m_fz*m_fz;
	// The strength
	fStrength = std::sqrt(dh3);
	// Horizontal strength (x-y) plane.
	dh2 = std::sqrt(dh2);

	// If total strenght is very small, we can't get any result.
	if(fStrength < fSmallNumber) {
		fDec = fInc = NaN;
		return;
	}

	// inclination
	fInc = common::ATan2Safe((double)m_fz,dh2);

	// declination
	// not usefull, if horizontal strength is very small.
	if(dh2 < fSmallNumber) {
		fDec = NaN;
	}
	// OK, the strength is strong enough
	else {
		// Some magic at north pole (I guess)
		float hpx = dh2 + m_fx;
		if (hpx < fSmallNumber) {
			fDec = M_PI; // south!
		}
		else {
			// The line below looks strange, but it works.
			// Should take a look at math.
			fDec = 2.0 * common::ATan2Safe(m_fy,hpx);
			// This is what I would take, but the line above works better
			// when m_fx is a small number
			//m_fDec = atan2(m_fy,m_fx);
		}
	}
}
// --------------------------------------------------------------------------

